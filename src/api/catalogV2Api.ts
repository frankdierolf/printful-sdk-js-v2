/**
 * API Documentation v2 | Printful
 * # About the Printful API  <div class=\"alert alert-info\">     <h3>Welcome to API v2 BETA</h3>      <ul>         <li>            We’re excited to inform you that the new major version of our API just went live, and we want to invite you to participate in the Open Beta test.              Please keep in mind that this release is still in BETA, although all presented endpoints can be used in a production environment.              Since this is a BETA release, we are keen on adopting any changes to our API (which we encourage you to pass via <a href=\"https://forms.gle/Yq4t1poQQR8Mwoyt5\">this feedback form</a>).             We do not expect to introduce any breaking changes to the current form of endpoints, although the final form of each endpoint might slightly vary from the current version.         </li>     </ul> </div> <br>  * **What is the plan for the new endpoints V2s.**  * **How to use new endpoints?**     Create or use an already created private token for authorization.      Unless it\'s stated otherwise, the v2 version of Printful API may be used like the v1 version.     All v2 endpoints use **_/v2** prefix and the specifics of each endpoint are explained in a dedicated section.     * **Test and provide feedback:** Explore the new features, experiment with the enhancements, and share your feedback through our dedicated [feedback form](https://forms.gle/Yq4t1poQQR8Mwoyt5).  ### What is new in the V2s  - The flexibility of order creation with itemized order building [(read more)](#tag/Orders-v2). - Simplifying embroidery orders: auto thread color detection as default, simplified thread colors definition on the layer level. - New, powerful design creation with multiple design layers support and positioning for order items and sync variants [(read more)](#tag/Orders-v2). - New, more secure Webhooks by enforcing HTTPS, added expiration date, and request signing. - More flexibility in webhook per event configuration.  - New webhook events – a new event for catalog price change, and the stock update event is now real-time with a refresh rate every 5 minutes (previously every 24h). - More information in the Catalog about the products (images, discounted pricing, placement information). - More flexibility in the catalog (extensive filtering and sorting options, DSR support, pagination). - More information on the order shipment level – more precise EDT, departure country, and shipment tracking events. - Standardization of returned time in API – standardized format according to ISO 8601, UTC time zone. - Standardization of returned price formats in API. Prices are displayed as a string with up to 2 decimal points. - Uniform pagination parameters across all endpoints. - Performance improvements for all endpoints.
 *
 * The version of the OpenAPI document: 2.0.0-beta
 * Contact: devsupport@printful.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { GetCategories200Response } from '../model/getCategories200Response';
import { GetCategoriesByProductId200Response } from '../model/getCategoriesByProductId200Response';
import { GetCategoryById200Response } from '../model/getCategoryById200Response';
import { GetMockupTemplatesByProductId200Response } from '../model/getMockupTemplatesByProductId200Response';
import { GetOAuthScopes401Response } from '../model/getOAuthScopes401Response';
import { GetProductById200Response } from '../model/getProductById200Response';
import { GetProductImagesById200Response } from '../model/getProductImagesById200Response';
import { GetProductPricesById200Response } from '../model/getProductPricesById200Response';
import { GetProductSizeGuideById200Response } from '../model/getProductSizeGuideById200Response';
import { GetProductSizeGuideById404Response } from '../model/getProductSizeGuideById404Response';
import { GetProductStockAvailabilityById200Response } from '../model/getProductStockAvailabilityById200Response';
import { GetProductStockAvailabilityById400Response } from '../model/getProductStockAvailabilityById400Response';
import { GetProductStockAvailabilityById403Response } from '../model/getProductStockAvailabilityById403Response';
import { GetProductVariantsById200Response } from '../model/getProductVariantsById200Response';
import { GetProducts200Response } from '../model/getProducts200Response';
import { GetVariantById200Response } from '../model/getVariantById200Response';
import { GetVariantImagesById200Response } from '../model/getVariantImagesById200Response';
import { GetVariantPricesById200Response } from '../model/getVariantPricesById200Response';
import { GetVariantStockAvailabilityById200Response } from '../model/getVariantStockAvailabilityById200Response';
import { RetrieveMockupStylesByProductId200Response } from '../model/retrieveMockupStylesByProductId200Response';
import { RetrieveMockupStylesByProductId401Response } from '../model/retrieveMockupStylesByProductId401Response';
import { RetrieveMockupStylesByProductId404Response } from '../model/retrieveMockupStylesByProductId404Response';
import { ServerErrorDetails } from '../model/serverErrorDetails';
import { TechniqueEnum } from '../model/techniqueEnum';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.printful.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum CatalogV2ApiApiKeys {
}

export class CatalogV2Api {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth': new OAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: CatalogV2ApiApiKeys, value: string) {
        (this.authentications as any)[CatalogV2ApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth.accessToken = token;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Returns list of all categories that are present in the catalog. The categories specify the type of the product that is associated with it. For example, the category \"Men’s T-shirts\" indicates that the product is a subgroup of T-shirts specifically targeted at Men. Categories can be used to filter the product list by specific tags [See categories_ids](#operation/getProducts) 
     * @summary Retrieve a list of catalog categories
     */
    public async getCategories (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetCategories200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-categories';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetCategories200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetCategories200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * To retrieve information about a particular products categories, use this feature. It returns details about the catalog categories associated with the catalog product. Categories help identify the type of product associated with them. For instance, the category \"Men\'s T-shirts\" denotes that the product is a subgroup of T-shirts intended for men. 
     * @summary Retrieve a list of catalog product categories
     * @param id Product ID.
     */
    public async getCategoriesByProductId (id: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetCategoriesByProductId200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products/{id}/catalog-categories'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCategoriesByProductId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetCategoriesByProductId200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetCategoriesByProductId200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns information about a specific catalog category. The categories specify the type of the product that is associated with it. For example, the category \"Men’s T-shirts\" indicates that the product is a subgroup of T-shirts specifically targeted at Men. Categories can be used to filter the product list by specific tags [See categories_ids](#operation/getProducts) 
     * @summary Retrieve information about specific category
     * @param id Category ID
     */
    public async getCategoryById (id: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetCategoryById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-categories/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCategoryById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetCategoryById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetCategoryById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns positional data for specified catalog product mockups. The data from this endpoint could be used to generate your own mockups without the need to use Printful\'s mockup generator. ![Mockup template](images/mockups/mockup_template.png) 
     * @summary Retrieve catalog product mockup templates
     * @param id Product ID.
     * @param placements One or more identifiers of a placement to return only products with variants that have that placement. The complete list of placements can be found [here](https://developers.printful.com/docs/#section/Placements).
     * @param sellingRegionName Only returns the products that can be sold in the specified region.
     * @param limit The number of results to return per page.
     * @param offset The number of results to not include in the response starting from the beginning of the list.  This can be used to return results after the initial 100. For example, sending offset 100 
     */
    public async getMockupTemplatesByProductId (id: number, placements?: Array<string>, sellingRegionName?: 'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions', limit?: number, offset?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetMockupTemplatesByProductId200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products/{id}/mockup-templates'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMockupTemplatesByProductId.');
        }

        if (placements !== undefined) {
            localVarQueryParameters['placements'] = ObjectSerializer.serialize(placements, "Array<string>");
        }

        if (sellingRegionName !== undefined) {
            localVarQueryParameters['selling_region_name'] = ObjectSerializer.serialize(sellingRegionName, "'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetMockupTemplatesByProductId200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetMockupTemplatesByProductId200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns information about a single specified catalog product. [See catalog product](#tag/Catalog-v2/What-is-a-catalog-product) 
     * @summary Retrieve a single catalog product
     * @param id Product ID.
     * @param sellingRegionName Only returns the products that can be sold in the specified region.
     */
    public async getProductById (id: number, sellingRegionName?: 'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetProductById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductById.');
        }

        if (sellingRegionName !== undefined) {
            localVarQueryParameters['selling_region_name'] = ObjectSerializer.serialize(sellingRegionName, "'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetProductById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetProductById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This feature helps to fetch blank images for a catalog product. These blank images are always white and semi-transparent and can be colored by the user on the client-side as per the specified color in the `data.color` field. The endpoint allows filtering of the result based on the type of the mockup, the placement, and the color of the product. 
     * @summary Retrieve blank images for a catalog product
     * @param id Product ID.
     * @param mockupStyleIds Used to specify style of images For example:   * On the hanger   * On the Male/Female model   * Flat on the table   * etc. Available mockup styles for catalog product can be found under _[Retrieve catalog product mockup styles](#operation/retrieveMockupStylesByProductId)_. 
     * @param colors String values separated by comma. You can specify multiple variant colors filters.
     * @param placement Filters result by specified placement
     */
    public async getProductImagesById (id: number, mockupStyleIds?: number, colors?: string, placement?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetProductImagesById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products/{id}/images'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductImagesById.');
        }

        if (mockupStyleIds !== undefined) {
            localVarQueryParameters['mockup_style_ids'] = ObjectSerializer.serialize(mockupStyleIds, "number");
        }

        if (colors !== undefined) {
            localVarQueryParameters['colors'] = ObjectSerializer.serialize(colors, "string");
        }

        if (placement !== undefined) {
            localVarQueryParameters['placement'] = ObjectSerializer.serialize(placement, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetProductImagesById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetProductImagesById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Calculates prices for specific catalog product based on selling region and specified currency. Calculations also include Store discounts. Selling region is used to specify product production currency, that is the price that the product is natively manufactured in. Different selling regions might affect the overall price amount. Currency parameter is used only to define the currency that the prices will be displayed in. 
     * @summary Retrieve catalog product prices
     * @param id Product ID.
     * @param sellingRegionName Specifies the region production currency that the product prices will be calculated in
     * @param currency The currency (3-letter code) used to determine currency in which the prices will be displayed. The store currency will be used by default. The format is compliant with ISO 4217 standard.
     */
    public async getProductPricesById (id: number, sellingRegionName?: string, currency?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetProductPricesById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products/{id}/prices'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductPricesById.');
        }

        if (sellingRegionName !== undefined) {
            localVarQueryParameters['selling_region_name'] = ObjectSerializer.serialize(sellingRegionName, "string");
        }

        if (currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetProductPricesById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetProductPricesById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns information about the size guide for a specific product.
     * @summary Retrieve size guide for a catalog product
     * @param id Product ID.
     * @param unit A comma-separated list of measurement unit in which size tables are to be returned (&#x60;inches&#x60; or &#x60;cm&#x60;). The default value is determined based on the locale country. The inches are used for United States, Liberia and Myanmar, for other countries the unit defaults to centimeters. 
     */
    public async getProductSizeGuideById (id: number, unit?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetProductSizeGuideById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products/{id}/sizes'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductSizeGuideById.');
        }

        if (unit !== undefined) {
            localVarQueryParameters['unit'] = ObjectSerializer.serialize(unit, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetProductSizeGuideById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetProductSizeGuideById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Provides information about the catalog product stock status. Stock availability is grouped by variants &rarr; techniques &rarr; selling regions. 
     * @summary Retrieve catalog product stock availability
     * @param id Product ID.
     * @param techniques One or more techniques to return only products with variants that can be printed using one of the techniques.
     * @param sellingRegionName Only returns the products that can be sold in the specified region.
     * @param limit The number of results to return per page.
     * @param offset The number of results to not include in the response starting from the beginning of the list.  This can be used to return results after the initial 100. For example, sending offset 100 
     */
    public async getProductStockAvailabilityById (id: number, techniques?: Array<TechniqueEnum>, sellingRegionName?: 'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions', limit?: number, offset?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetProductStockAvailabilityById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products/{id}/availability'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductStockAvailabilityById.');
        }

        if (techniques !== undefined) {
            localVarQueryParameters['techniques'] = ObjectSerializer.serialize(techniques, "Array<TechniqueEnum>");
        }

        if (sellingRegionName !== undefined) {
            localVarQueryParameters['selling_region_name'] = ObjectSerializer.serialize(sellingRegionName, "'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetProductStockAvailabilityById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetProductStockAvailabilityById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns information about all catalog variants associated with the specified catalog product. [See catalog variant](#tag/Catalog-v2/What-is-a-catalog-variant) 
     * @summary Retrieve information about catalog product variants
     * @param id Product ID.
     */
    public async getProductVariantsById (id: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetProductVariantsById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products/{id}/catalog-variants'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductVariantsById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetProductVariantsById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetProductVariantsById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This endpoint retrieves a list of the products available in Printful\'s catalog. The list is paginated and can be filtered using various filters. The information returned includes details on how each product can be designed, such as the available placements, techniques, and additional options. For a visual representation of the design data, please see the following diagram: [<img src=\"images/catalog/design_data_diagram.png#center\" width=\"700\"/>](images/catalog/design_data_diagram.png) 
     * @summary Retrieve a list of catalog products
     * @param categoryIds One or more category IDs to return only products in those categories. The IDs can be found in the response of the operation _[Get Categories](#operation/getCategories)_. 
     * @param colors One or more color names to return only products with variants of one the those colors. 
     * @param limit The number of results to return per page.
     * @param _new If true only new Products will be returned.
     * @param offset The number of results to not include in the response starting from the beginning of the list.  This can be used to return results after the initial 100. For example, sending offset 100 
     * @param placements One or more identifiers of a placement to return only products with variants that have that placement. The complete list of placements can be found [here](https://developers.printful.com/docs/#section/Placements).
     * @param sellingRegionName Only returns the products that can be sold in the specified region.
     * @param sortDirection This parameter only is used if sort_type is also present and it changes the order of the returned products. The exact meaning varies depending on the value of &#x60;sort_type&#x60;: * &#x60;sort_type&#x3D;new&#x60;   * ascending sorts from newest to oldest.   * descending sorts from oldest to newest. * &#x60;sort_type&#x3D;rating&#x60;  * ascending from lowest to highest rated.  * descending from highest to lowest rated. * &#x60;sort_type&#x3D;price&#x60;  * ascending from lowest to highest price.  * descending from highest to lowest price. 
     * @param sortType The sorting strategy to use when sorting the result. When it\&#39;s not present, no specific order is guaranteed. 
     * @param techniques One or more techniques to return only products with variants that can be printed using one of the techniques.
     */
    public async getProducts (categoryIds?: Array<number>, colors?: Array<string>, limit?: number, _new?: boolean, offset?: number, placements?: Array<string>, sellingRegionName?: 'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions', sortDirection?: 'ascending' | 'descending', sortType?: 'new' | 'rating' | 'price', techniques?: Array<TechniqueEnum>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetProducts200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (categoryIds !== undefined) {
            localVarQueryParameters['category_ids'] = ObjectSerializer.serialize(categoryIds, "Array<number>");
        }

        if (colors !== undefined) {
            localVarQueryParameters['colors'] = ObjectSerializer.serialize(colors, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (_new !== undefined) {
            localVarQueryParameters['new'] = ObjectSerializer.serialize(_new, "boolean");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (placements !== undefined) {
            localVarQueryParameters['placements'] = ObjectSerializer.serialize(placements, "Array<string>");
        }

        if (sellingRegionName !== undefined) {
            localVarQueryParameters['selling_region_name'] = ObjectSerializer.serialize(sellingRegionName, "'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions'");
        }

        if (sortDirection !== undefined) {
            localVarQueryParameters['sort_direction'] = ObjectSerializer.serialize(sortDirection, "'ascending' | 'descending'");
        }

        if (sortType !== undefined) {
            localVarQueryParameters['sort_type'] = ObjectSerializer.serialize(sortType, "'new' | 'rating' | 'price'");
        }

        if (techniques !== undefined) {
            localVarQueryParameters['techniques'] = ObjectSerializer.serialize(techniques, "Array<TechniqueEnum>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetProducts200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetProducts200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns information about single specified catalog variant. [See catalog variant](#tag/Catalog-v2/What-is-a-catalog-variant) 
     * @summary Retrieve information about specific catalog variant
     * @param id Variant ID
     */
    public async getVariantById (id: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetVariantById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-variants/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVariantById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetVariantById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetVariantById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns images for a specified Variant.
     * @summary Retrieve blank images for a catalog variant
     * @param id Variant ID
     * @param mockupStyleIds Used to specify style of images For example:   * On the hanger   * On the Male/Female model   * Flat on the table   * etc. Available mockup styles for catalog product can be found under _[Retrieve catalog product mockup styles](#operation/retrieveMockupStylesByProductId)_. 
     * @param placement Filters result by specified placement
     */
    public async getVariantImagesById (id: number, mockupStyleIds?: number, placement?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetVariantImagesById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-variants/{id}/images'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVariantImagesById.');
        }

        if (mockupStyleIds !== undefined) {
            localVarQueryParameters['mockup_style_ids'] = ObjectSerializer.serialize(mockupStyleIds, "number");
        }

        if (placement !== undefined) {
            localVarQueryParameters['placement'] = ObjectSerializer.serialize(placement, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetVariantImagesById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetVariantImagesById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return pricing information from a single variant and the parent product
     * @summary Retrieve pricing information for the catalog variant
     * @param id Variant ID
     * @param sellingRegionName Specifies the region production currency that the product prices will be calculated in
     * @param currency The currency (3-letter code) used to determine currency in which the prices will be displayed. The store currency will be used by default. The format is compliant with ISO 4217 standard.
     */
    public async getVariantPricesById (id: number, sellingRegionName?: string, currency?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetVariantPricesById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-variants/{id}/prices'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVariantPricesById.');
        }

        if (sellingRegionName !== undefined) {
            localVarQueryParameters['selling_region_name'] = ObjectSerializer.serialize(sellingRegionName, "string");
        }

        if (currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetVariantPricesById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetVariantPricesById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Provides information about the catalog variant stock status. Stock availability is grouped by variants &rarr; techniques &rarr; selling regions. 
     * @summary Retrieve catalog variant stock availability
     * @param id Variant ID
     * @param techniques One or more techniques to return only products with variants that can be printed using one of the techniques.
     * @param sellingRegionName Only returns the products that can be sold in the specified region.
     */
    public async getVariantStockAvailabilityById (id: number, techniques?: Array<TechniqueEnum>, sellingRegionName?: 'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetVariantStockAvailabilityById200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-variants/{id}/availability'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVariantStockAvailabilityById.');
        }

        if (techniques !== undefined) {
            localVarQueryParameters['techniques'] = ObjectSerializer.serialize(techniques, "Array<TechniqueEnum>");
        }

        if (sellingRegionName !== undefined) {
            localVarQueryParameters['selling_region_name'] = ObjectSerializer.serialize(sellingRegionName, "'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetVariantStockAvailabilityById200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetVariantStockAvailabilityById200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns information about available mockup styles for specified catalog product. 
     * @summary Retrieve catalog product mockup styles
     * @param id Product ID.
     * @param placements One or more placement idenitifiers used to filter in mockup styles that match a given placement. The complete list of placements can be found [here](https://developers.printful.com/docs/#section/Placements).
     * @param sellingRegionName Only returns the products that can be sold in the specified region.
     * @param offset Result set offset
     * @param limit Number of items per page (max 100)
     */
    public async retrieveMockupStylesByProductId (id: number, placements?: Array<string>, sellingRegionName?: 'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions', offset?: number, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RetrieveMockupStylesByProductId200Response;  }> {
        const localVarPath = this.basePath + '/v2/catalog-products/{id}/mockup-styles'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling retrieveMockupStylesByProductId.');
        }

        if (placements !== undefined) {
            localVarQueryParameters['placements'] = ObjectSerializer.serialize(placements, "Array<string>");
        }

        if (sellingRegionName !== undefined) {
            localVarQueryParameters['selling_region_name'] = ObjectSerializer.serialize(sellingRegionName, "'worldwide' | 'north_america' | 'canada' | 'europe' | 'spain' | 'latvia' | 'uk' | 'france' | 'australia' | 'japan' | 'new_zealand' | 'italy' | 'brazil' | 'southeast_asia' | 'republic_of_korea' | 'english_speaking_regions'");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.OAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RetrieveMockupStylesByProductId200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RetrieveMockupStylesByProductId200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
